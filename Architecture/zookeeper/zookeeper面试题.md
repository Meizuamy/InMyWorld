## zookeeper 用来做什么的，有几种类型的节点

### zookeeper 提供了什么
1. 文件系统
zookeeper 维护了一个类似文件系统的数据结构。每个子目录项都被成为znode,和文件系统类似，我们能够自由的增加、删除、znode,在znode下增加、删除子node,唯一的不同在于znode是可以存储数据的。

有四种类型的znode
* PERSISTENT -- 持久化目录节点

客户端与 zookeeper 断开连接后，该节点依旧存在。

* PERSITENT_SEQUENTIAL - 持久化顺序编号目录节点

客户端与zookeeper 断开连接后，该节点依旧存在，知识zookeeper给该节点名称进行顺序编号

* EPHEMERAL - 临时目录节点

客户端与zookeeper断开连接后，该节点被删除

* EPHEMERAL_SEQUENTIAL - 临时顺序编号目录节点

客户端与zookeeper断开连接后，该节点被深处，知识zookeeper给该节点名称进行顺序编号。

2. 通知机制

客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变，被删除，子目录节点增加删除）等，zookeeper会通知客户端。

## zookeeper 可以做什么

1. 命名服务

在zookeeper的文件系统里创建一个目录，即有唯一的path,在我们使用`??tborg`无法确定上有程序的部署集器时即可与下游程序约定号path，通过path即能互相探索发现。


2. 配置管理

程序总是需要配置的，如果程序分散部署在多台集器上，要逐个改变配置就变得困难。我们可以把这些配置全部放到zookeeper上去，保存在zookeeper的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序都会收到zookeeper的通知，然后从zookeeper获取新的配置信息应用到系统中。


3. 集群管理（选举[raft](https://www.cnblogs.com/xybaby/p/10124083.html)）

* 机器加入和退出

所有集器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有集器挂掉，该集器与zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他集器都收到通知：某个兄弟节点被删除，所有其他机器都收到通知，某个兄弟目录被删除。新机器加入也时类似，所有机器都收到通知，新兄弟目录加入了，highCount又有了。


* 选举master

根据上述描述，所有机器在创建临时顺序编号目录节点时，每次选取编号最小的机器作为master就好。这里raft算法较为复杂，以后补充

todo : raft 算法补充

4. 分布式锁

有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序（同步锁）

* 独占

我们可以将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建一个新的节点，最终成功创建的那个客户端也即拥有了这把锁。

* 同步

使用当前已经存在的节点，在此节点下创建新的节点，新创建的节点如果是编号最小的，则获得此锁，用完之后删除，依次获取锁。

5. 队列管理

* 同步队列

当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。

* FIFO队列

第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
第二类，和分布式锁服务中的控制时序场景基本原理一直，入列有编号，出列按编号。



