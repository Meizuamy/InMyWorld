# 六大范式

## 第一范式 ：`属性不可拆分`或`无重复列`

一个属性不允许再分成多个属性建立列。事实上，在目前的DBMS中是不可能拆分属性的，因为他们不允许这么做。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。第一范式的模式要求属性值不可再分裂成更小的部分，即属性项不能是属性组合或是由一组属性构成。简而言之，第一范式就是无重复列。例如：由“职工号”“姓名”“电话号码”组成的表（一个人可能有一部办公电话和一部移动电话），这时将其规范化为1NF可以将电话号码分为“办公电话” 和 “移动电话” 两个属性，即职工（职工号，姓名，办公电话，移动电话）。

## 第二范式(2NF)：（有且只有一个唯一的主键，并且非主属性对候选键是完全依赖）
（候选键可以是一个，也可以是两个，如果是关系表，一个候选键中一般有两个主属性，所以非主属性对候选键中的两个主属性的依赖，就要看是否是完全依赖。部分依赖会引起数据冗余）
第二范式（2NF)是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。

### 完全函数依赖

部分函数依赖，就是多个属性决定另一个属性，但事实上，这多个属性是有冗余的。例如：（学号,班级）-> 姓名，事实上，只需要学号能决定姓名，因此班级是冗余的，应该去掉。

如果关系模型R为第一范式，并且R中的每一个非主属性完全函数依赖于R的某个候选键，则称R为第二范式模式（如果A是关系模式R的候选键的一个属性，则称A是R的主属性，否则成A是R的非主属性）

因此第二范式的目标就是消除函数依赖中左边存在的冗余属性。

## 第三范式（3NF)：消除传递依赖

满足第三范式的数据表必须先满足第二范式，也就是说，数据库中的非主属性仅能依赖于候选键，不存在与其他非主属性的关联。

一般系统设计需要符合第三范式。

第三范式简而言之是两个关联的表，一个表只能由另一个表的候选键，不能有共同的非主属性。即两个关联表，一个表A有另一个表B的非主属性C，表A有候选键a和b,b也是表B的候选键，此时的传递依赖关系为：A-B，B-C。此时不满足第三范式。

## BC范式（BCNF）：（候选码存在多个属性时，多个主属性直接要消除传递依赖关系）
1. 所有的非主属性对每一个码都是完全函数依赖
2. 所有的主属性对于每一个不包含它的码，也是完全函数依赖；
3. 没有任何属性完全函数依赖于非码的任意一个组合。

R属于3NF，不一定属于BCNF，如果R属于BCNF，一定属于3NF

## 第四范式（4NF）：（一个表的主键只对应一个多值）

对于每一个 x->y, x都能找到一个候选码（若关系中的某艺术性组的值能唯一的标识一个元组，而其真子集不行，则称该属性组为候选码）

设R是一个关系模型，D是R上的多值依赖集合。如果D中存在凡多值依赖x->y时，x必是R的超键，那么称R是第四范式的模式。


## 第五范式（5NF）：投影连接范式

在不存在多值属性、不存在实体的属性部分依赖于主属性、不存在非主属性依赖于其他非主属性、主属性内部不能有部分或传递依赖、不存在多值依赖的基础上。

`消除连接依赖，并且必须保证数据完整性`

## 总结

第一范式、第二范式是对于表内约束，第二范式、BC范式和第四范式涉及多表。

1. 第一范式比较简单，属性不可拆分。
2. 第二范式不难理解，非主属性对候选键完全依赖，不能存在部分依赖。候选键只有一个主属性时则一定符合第二范式。候选键包含多个主属性时，可能出现不符合第二范式的情况，就是非主属性对多个属性候选键部分函数依赖。在非主属性对多属性候选键完全函数依赖时，才符合第二范式。
3. 第三方式去除冗余，非主属性只能存在一个表中，不应该存在多个表中，要去除无意义的数据冗余。
4. BC范式则不应存在关键字决定关键字的情况。也就是在关联表中，一个表有多个属性构成符合的候选键，主属性不应该直接有相互依赖。工号和身份证是相互依赖。
5. 第四范式，对于候选键只能存在不超过1个多值属性。要求把同一表内的多对多关系删除。


## 引用文章出处

https://www.jianshu.com/p/71563d6b121d